---
title: "Compresión imágenes RGB"
author: "jemarle"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
urlcolor: blue
header-includes:
   - \usepackage{multirow}
   - \usepackage{tikz} # Diagramas Latex
   - \usetikzlibrary{positioning}
   - \usepackage{float}
   - \usepackage[font=small,labelfont=bf,labelsep=period]{caption} 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Compresión de imágenes single-level con PyWavelets

Para la realización de la Transformada Discreta Wavelet 2D, así como de su inversa, lo más cómodo en Python es hacer uso de la librería `PyWavelets`, la cual puede instalarse haciendo uso de `pip install PyWavelets`. $\\$

## Función diseñada para el análisis y su aplicación

Una función fue diseñada (ver código) para realizar esta a nivel único (`single level`), de tal forma que se puede analizar rápidamente una imagen comprimida por la transformación wavelet para un determinado nivel de aproximación y detalle. Esto se hizo principalmente gracias a las funciones `wavedec2` e `idwt2` del módulo de [PyWavelets](https://pywavelets.readthedocs.io/en/latest/ref/2d-dwt-and-idwt.html). Nuestra función `compress_image` a su vez permite trabajar tanto con imágenes en escala de grises como en RGB. Posee la capacidad de elegir entre los distintos tipos de `wavelet`, `modos de thresholding` o valor de `threshold`. $\\$

La aplicación de `compress_image` a una imagen (presente en `"./data/genshin.jpg"`) muestra lo siguiente:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./data/Memoria/Compress_image_genshin.png}
  \caption{Visualización de la aproximación y de los detalles horizontales, verticales y diagonales en una fotografía en RGB.}
  \label{fig:compress_image_1}
\end{figure}

En la Figura \ref{fig:compress_image_1} se aprecia una representación en escala de grises de lo que capturan nuestros coeficientes Wavelet para cada uno de los canales de la imagen: Red, Green y Blue. En este caso el análisis se hace para el primer nivel, mostrando los detalles horizontales, verticales y diagonales, en ese orden. $\\$

Por otra parte, se tiene una compración entre la imagen original y la comprimida.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./data/Memoria/Compress_image_genshin_2.png}
  \caption{Comparación entre la imagen original y modificada en el caso RGB.}
  \label{fig:compress_image_2}
\end{figure}

Apreciamos en la Figura \ref{fig:compress_image_2} que nuestra compresión ha utilizado el Wavelet `haar`, un `threshold` de 100 y con un modo `hard`, obteniendo una reducción del 65.98 % del tamaño inicial.

Un ejemplo en blanco y negro también es posible realizarlo, usando la imagen presente en `"./data/nino.jpg"`.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./data/Memoria/Compress_image_nino.png}
  \caption{Visualización de la aproximación y de los detalles horizontales, verticales y diagonales en una fotografía en escala de grises.}
  \label{fig:compress_image_3}
\end{figure}

En la Figura \ref{fig:compress_image_3} pueden apreciarse claramente los detalles según la dirección, resultando muy interesante a nivel teórico. La comparación entre la imagen original y comprimida se muestra a continuación.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{./data/Memoria/Compress_image_nino_2.png}
  \caption{Comparación entre imagen original y modificada en el caso de escala de grises.}
  \label{fig:compress_image_4}
\end{figure}

La reducción en tamaño en este caso es del 77.38 %. Nótese que se ha utilizado en este caso el modo de thresholding `soft`, lo que permite en la mayoría de casos una reducción de ruido sin sacrificar demasiados detalles importantes, tal y como se aprecia en este caso.

**Nota**: los detalles han sido en todos los casos ecualizados utilizando la función `exposure.equalize_hist()` del módulo `exposure` de la biblioteca `scikit-learn`. Esto es muy útil pues permite el resalte de los detalles para que sean visibles al lector.

**Aplicación de la función**: en el código se ha añadido una forma de comprimir una carpeta completa de imágenes con la correspondiente creación de otra comprimida. ¡Esto permite al usuario reducir el tamaño de sus imágenes si no quiere usar un .zip! 

## Comparación entre distintos wavelets, threshold values y modos

Para hacer una comparación entre lo que se obtiene con distintos wavelets, valores de umbral y modos de aplicación de esos umbrales lo único que se tuvo que hacer fue iterar llamando a la función `compress_image` con los distintos valores deseados. Un ejemplo de ello se muestra en la Figura \ref{fig:comparacion}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{./data/Memoria/Comparacion.png}
  \caption{Comparación entre distintos wavelets, valores umbral y modos de threshold.}
  \label{fig:comparacion}
\end{figure}

Puede observarse una cierta tendencia del modo `soft` a oscurecer la imagen en un intento de suavizar los coeficientes. El modo `garrote`, por otra parte, tiende a ser algo agresivo como `hard` para valores de coeficientes altos (los deja prácticamente igual). Sin embargo, este representa una transición entre `soft` y `hard` al comportarse de manera similar a `soft` para valores bajos. Es inmediato también apreciar cómo un aumento en el threshold acompaña un incremento en la reducción del tamaño de la imagen.

## Búsqueda de un threshold adecuado para un porcentaje de reducción deseado

La función propia diseñada llamada `find_optimal_threshold` nos permite que dada una imagen, una compresión buscada con una familia y modo de thresholding fijo, obtener el threshold adecuado para un porcentaje de compresión buscado. Esta función básicamente itera de forma optimizada (con un paso adaptativo) sobre las distintas imágenes que se generarían para un threshold dado (ver código). El proceso iterativo para la imagen `"./data/genshin.jpg" se muestra en la siguiente Figura.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{./data/Memoria/Find_threshold_image.png}
  \caption{Representación del proceso iterativo en la búsqueda de la reducción deseada.}
  \label{fig:find_threshold}
\end{figure}

Observamos que el *threshold final* que nos ofrece esta función sería 290. La razón por la que no se llega estrictamente a la reducción deseada es por una tolerancia implementada para evitar un bucle muy largo. La imagen con esta compresión se muestra a continuación.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{./data/Memoria/Find_threshold_image_2.png}
  \caption{Imagen obtenida tras la búsqueda de la reducción deseada.}
  \label{fig:threshold_image}
\end{figure}



